{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 61, "column": 0}, "map": {"version":3,"sources":["file:///Users/azarmacbook/Cursor%20Projects/PMP-%20Reports/src/lib/db.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client';\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nexport const prisma = globalForPrisma.prisma ?? new PrismaClient();\n\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma; "],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SAAS,gBAAgB,MAAM,IAAI,IAAI,6IAAY;AAEhE,wCAA2C,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 74, "column": 0}, "map": {"version":3,"sources":["file:///Users/azarmacbook/Cursor%20Projects/PMP-%20Reports/src/app/api/admin/positions/%5Bid%5D/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server';\nimport { z } from 'zod';\nimport { prisma } from '@/lib/db';\n\nconst updatePositionSchema = z.object({\n  name: z.string().min(1, 'Position name is required').optional(),\n  description: z.string().optional().or(z.literal('')),\n  monthlyRate: z.number().min(0, 'Monthly rate must be positive').optional().or(z.literal(null)),\n  isActive: z.boolean().optional(),\n});\n\n// GET - Fetch single position by ID\nexport async function GET(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const { id } = await params;\n    const positionId = parseInt(id);\n    \n    if (isNaN(positionId)) {\n      return NextResponse.json(\n        { success: false, error: 'Invalid position ID' },\n        { status: 400 }\n      );\n    }\n\n    const position = await prisma.position.findUnique({\n      where: { id: positionId },\n    });\n\n    if (!position) {\n      return NextResponse.json(\n        { success: false, error: 'Position not found' },\n        { status: 404 }\n      );\n    }\n\n    return NextResponse.json({ success: true, data: position });\n  } catch (error) {\n    console.error('Error fetching position:', error);\n    return NextResponse.json(\n      { success: false, error: 'Failed to fetch position' },\n      { status: 500 }\n    );\n  }\n}\n\n// PUT - Update position\nexport async function PUT(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const { id } = await params;\n    const positionId = parseInt(id);\n    \n    if (isNaN(positionId)) {\n      return NextResponse.json(\n        { success: false, error: 'Invalid position ID' },\n        { status: 400 }\n      );\n    }\n\n    const body = await request.json();\n    const validatedData = updatePositionSchema.parse(body);\n\n    // Check if position exists\n    const existingPosition = await prisma.position.findUnique({\n      where: { id: positionId }\n    });\n\n    if (!existingPosition) {\n      return NextResponse.json(\n        { success: false, error: 'Position not found' },\n        { status: 404 }\n      );\n    }\n\n    const position = await prisma.position.update({\n      where: { id: positionId },\n      data: {\n        ...validatedData,\n        name: validatedData.name?.trim(),\n        description: validatedData.description?.trim() || null,\n        monthlyRate: validatedData.monthlyRate || null,\n      },\n    });\n\n    return NextResponse.json({ success: true, data: position });\n  } catch (error) {\n    console.error('Error updating position:', error);\n    if (error instanceof z.ZodError) {\n      return NextResponse.json(\n        { success: false, error: 'Validation error', details: error.errors },\n        { status: 400 }\n      );\n    }\n    if (error.code === 'P2002') {\n      return NextResponse.json(\n        { success: false, error: 'Position name already exists' },\n        { status: 409 }\n      );\n    }\n    return NextResponse.json(\n      { success: false, error: 'Failed to update position' },\n      { status: 500 }\n    );\n  }\n}\n\n// DELETE - Delete position\nexport async function DELETE(\n  request: NextRequest,\n  { params }: { params: Promise<{ id: string }> }\n) {\n  try {\n    const { id } = await params;\n    const positionId = parseInt(id);\n    \n    if (isNaN(positionId)) {\n      return NextResponse.json(\n        { success: false, error: 'Invalid position ID' },\n        { status: 400 }\n      );\n    }\n\n    // Check if position exists\n    const existingPosition = await prisma.position.findUnique({\n      where: { id: positionId }\n    });\n\n    if (!existingPosition) {\n      return NextResponse.json(\n        { success: false, error: 'Position not found' },\n        { status: 404 }\n      );\n    }\n\n    await prisma.position.delete({\n      where: { id: positionId },\n    });\n\n    return NextResponse.json({ success: true, message: 'Position deleted successfully' });\n  } catch (error) {\n    console.error('Error deleting position:', error);\n    return NextResponse.json(\n      { success: false, error: 'Failed to delete position' },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}